#region Chapter 1. Introduction to Algorithms
function Search-BinarySoftCycle  # двоичный поиск, исправленный книжный вариант (не задаётся лишний вопрос, когда остаётся одно число)
{<# напарник загадывает любое число из известного сортированного набора чисел, например, от 0 до 7 включительно (т.е. 8-мь чисел)
    вы называете число и в ответ слышите: "угадал" / "больше" / "меньше"
    сколько чисел нужно НАЗВАТЬ, прежде, чем вы узнаете загаданное?
    
    используя алгоритм двоичного поиска,
      вы определяете нижнюю (l) и верхнюю (h) границы поиска,
      называете число (m), находящееся посередине этих границ и, в зависимости от ответа ("угадал" / "больше" / "меньше"),
      переносите одну из границ, чтобы назвать новое среднее число,
    вы узнаете загаданное число не более, чем за N вопросов, где N означает степерь 2-ки:
      2^(N-1) < общее количество чисел <= 2^N
    
    т.е. для 8 чисел это не более 3х вопросов ( 8 <= 2^3 )
    
    $lst = @( 0, 1, 2, 3, 4, 5, 6, 7) ; $t = 7
    
    l = 0
    h = 7
    11111111111111111111111111111111111111111111111111111111111111111111111111111111
    1     m = (l + h) / 2 = (0 + 7) / 2 = 3
    1
    1     l             h
    1     0 1 2 3 4 5 6 7
    1           m
    1 это 3? - нет, больше! - ок, двигаем нижнюю границу сразу за серединку
    1     l = m + 1 = 3 + 1 = 4
    1     h = 7
    
    22222222222222222222222222222222222222222222222222222222222222222222222222222222
    2     m = (4+7)/2 = 5
    2
    2             l     h
    2     0 1 2 3 4 5 6 7
    2               m
    2 это 5? - нет, больше! - ок, снова двигаем нижнюю границу сразу за серединку
    2     l = m + 1 = 5 + 1 = 6
    2     h = 7
    2     m = (6+7)/2 = 6
    
    33333333333333333333333333333333333333333333333333333333333333333333333333333333
    3                 l h
    3     0 1 2 3 4 5 6 7
    3                 m
    3 это 6? - нет, больше! - значит 7, т.к. остались только 6 и 7 и про 7 можно не спрашивать
    #>
    
    param (
        $lst,   # отсортированный список чисел
        $target         # целевое, т.е. загаданное, число
    )
    
    
    try {
        [int[]] $lst = $lst
        # тут нужно преобразовывать тип $target к типу элементов $lst, чтобы избежать ситуации, когда "-1" -gt 1 даёт True
        
        # пока преобразование в лоб
        [int] $target = $target
    }
    catch {
        $_ | Write-Warning
        return -2
    }
    
    $low = 0  # нижняя граница поиска
    
    $high = $lst.Length - 1  # верхняя граница поиска
    
    $step = 0  # номер заданного вопроса
    
    while ($low -lt $high)  # цикл работает, пока границы отличаются друг от друга
    {
        $step++
        
        # нельзя, как в Python, просто взять и преобразовать число с плавающей точкой в целое
        #   [int]( ($low + $high) / 2 )
        # т.к. при таком преобразовании PoSh округлит результат не вниз, а до ближайшего чётного
        #   [int]( (0 + 5) / 2 ) # 2, ok
        #   [int]( (0 + 7) / 2 ) # 4, а ждали-то 3 ...
        # можно использовать специальные математические функции, например, [System.Math]::Truncate
        # но проще и быстрее сдвинуть сумму целых чисел вправо на 1 бит - эквивалент целочисленному делению на 2 :)
        #   (0 + 5) -shr 1  # 2, ok
        #   (0 + 7) -shr 1  # 3, ok
        $mid = ($low + $high) -shr 1
        
        if ($target -eq $lst[$mid])
        { # загаданное число совпало с серединкой |=> вернём количество вопросов
            return $step
        }
        elseif ($target -gt $lst[$mid])
        { # загаданное число больше серединки |=> ставим нижнюю границу сразу после серединки
            $low = $mid + 1
        }
        else
        { # загаданное число меньше серединки |=> ставим верхнюю границу сразу перед серединкой
            $high = $mid - 1
        }
    }
    
    # цикл завершился, а загаданное число вроде бы осталось неизвестным ...
    # 
    # на самом деле это не так, потому что в последний прогон цикла:
    #   во-первых, до проверки серединки, границы поиска указывали на пару соседних чисел (почти сомкнулись)
    #   во-вторых, серединка находится внутри границ и указывает на одно из этих двух чисел
    #   в-третьих, на вопрос "это серединка?" был ответ "больше" (или "меньше")
    #   т.е. границы поиска изменились последний раз и стали равны, что и завершило цикл
    # следовательно, искомое число уже известно и без дополнительного вопроса - это оставшееся число "не-серединка"
    # т.к. на нём сошлись границы поиска: $target = $lst[$high] = $lst[$low]
    # 
    # и это равенство можно использовать для проверки на честность - а было ли загаданное число из списка или нет? :)
    
    if ($target -eq $lst[$high] -and $target -eq $lst[$low])
    {  # честная игра, число известно методом исключения
        # "step={3}, `t target={0}, `t low={1}, `t high={2}" -f $target, $lst[$low], $lst[$high], $step | Write-Warning  # узнаём, что целевое число найдено "методом исключения", без доп. вопроса
        return $step
    }
    else
    {  # нечестная игра: число не из списка :)
        "Catched! There is no '{0}' in '{1}' list. :)" -f $target, ($lst[0..-1] -join '..') | Write-Warning
        return $null
    }
}


function Search-BinarySoftRecurse  # двоичный поиск, рекурсивный алгоритм, простая версия правил
{<# простая версия: задаётся вопрос про число (серединку), даются ответы "больше" / "меньше" / "угадал"
    поиск среди 2^N упорядоченных элементов потребует в лучшем случае 1 вопрос, в худшем случае - N вопросов
    т.к. если была загадана одна из серединок (2я, 3я и т.д.), то понадобится меньше попыток
    #>
    
    
    param (
        $lst,       # отсортированный список чисел
        $target,    # целевое число
        $step = 0,  # шаг (номер вопроса)
        $l = 0,     # нижняя граница
        $h = 0      # верхняя граница
    )
    
    
    if ($step -eq 0)  # БАЗОВАЯ ЧАСТЬ ФУНКЦИИ: проверим игру на честность, если ок - определяем границы и делаем первый шаг (рекурсивный вызов)
    {
        if ($target -in $lst)  # игра ок: загадано число из списка
        {
            $l = 0
            
            $h = $lst.Length - 1
            
            $step++
            
            return (Search-BinarySoftRecurse $lst $target $step $l $h)
        }
        else { return -1 }  # нечестная игра, числа нет в списке
    }
    else  # РЕКУРСИВНАЯ ЧАСТЬ ФУНКЦИИ: проверяем серединку, если да - вернём шаг, если нет - шаг внутрь :)
    {
        $m = ($l + $h) -shr 1
        
        if ($target -eq $lst[$m])
        {
            return $step  # угадали - возвращаем шаг
        }
        else
        {
            if ($target -gt $lst[$m])
            {
                $l = $m + 1  # загадано число после серединки |=> ставим нижнюю границу сразу после серединки
            }
            else
            {
                $h = $m - 1  # загадано число до серединки |=> ставим верхнюю границу сразу перед серединкой
            }
            
            if ($h -eq $l)
            {
                return $step  # границы сравнялись и указывают на искомое число
            }
            else
            {
                $step++
                
                return (Search-BinarySoftRecurse $lst $target $step $l $h)
            }
        }
    }
}


function Search-BinaryHardRecurse  # двоичный поиск, рекурсивный алгоритм, сложная версия правил
{<# помогает взглянуть на алгоритм со стороны по-битного определения целевого числа по одному биту за вопрос
    и звучит так
        - задаётся вопрос "находится ли загаданное число в диапазоне 0..middle?", т.е.  0 <= Target <= middle
        - даются ответы "да" / "нет"
    даже если это самая первая серединка, нужно задать ВСЕ вопросы, чтобы понять это,
    т.е. нужно задать каждый из N вопросов для 2^N чисел, чтобы определить загаданное число
    
    Пояснение на примере списка из 8 чисел '0 1 2 3 4 5 6 7 8' - видно, что необходимо и достаточно 3х вопросов:
        0   000
        1   001
        2   010
        3   011
        4   100
        5   101
        6   110
        7   111
        
        Задавая первый вопрос про серединку "находится ли искомое число в диапазоне от 0 до 3 включительно?"
        по сути мы спрашиваем "каков старший бит числа, 0 или 1?", точно также сокращая список вдвое:
            ответ "да" означает "3й бит равен 0", работаем со списком чисел 000..011
                0   000
                1   001
                2   010
                3   011
            
            ответ "нет" означает "3й бит равен 1" - список 100..111
                4   100
                5   101
                6   110
                7   111
        
        Аналогично, второй вопрос - узнаём ещё один бит числа
        "находится ли искомое число в диапазоне от 4 до 5 включительно"
            к примеру, ответ "нет", значит 2й бит числа тоже 1
                6   110
                7   111
        
        Третий вопрос будет последним, т.к. неизвестным остаётся только самый младший бит загаданного числа
            "от 6 до 6 ?" - "да"  |=> это 6   110
            "от 6 до 6 ?" - "нет" |=> это 7   111
    #>
    
    
    param (
        $lst,       # отсортированный список чисел
        $target,    # целевое число
        $step = 0,  # шаг (номер вопроса)
        $l = 0,     # нижняя граница
        $h = 0      # верхняя граница
    )
    
    
    if ($step -eq 0)  # БАЗОВАЯ ЧАСТЬ ФУНКЦИИ: проверим игру на честность, если ок - определяем границы и делаем первый шаг (рекурсивный вызов)
    {
        if ($target -in $lst)  # игра ок: загадано число из списка
        {
            $l = 0
            
            $h = $lst.Length - 1
            
            $step++
            
            return (Search-BinaryHardRecurse $lst $target $step $l $h)
        }
        else { return -1 }  # нечестная игра, числа нет в списке
    }
    else  # РЕКУРСИВНАЯ ЧАСТЬ ФУНКЦИИ: проверяем серединку, если да - вернём шаг, если нет - шагнём внутрь :)
    {
        
        $m = ($l + $h) -shr 1
        
        if ($target -ge $lst[$l] -and $target -le $lst[$m])
        {
            $h = $m  # число в диапазоне, сдвигаем верхнюю границу к середине
        }
        else
        {
            $l = $m + 1  # число в другом диапазоне, нижнюю границу ЗА середину
        }
        
        if ($l -eq $h)
        {
            return $step  # границы сравнялись, указывают на искомое число
        }
        else
        {
            $step++
            
            return (Search-BinaryHardRecurse $lst $target $step $l $h)
        }
    }
}
#endregion


#region Chapter 2. Selection Sort
function Find-Smallest
{
    [CmdletBinding()]
    param ( [System.Collections.ArrayList]$array )
    
    $Smallest = $array[0]
    
    $SmallestIndex = 0
    
    for ($i = 0; $i -lt $array.Count; $i++)
    {
        if ($array[$i] -lt $Smallest)  # если текущее значение меньше предыдущего - запомним это значение и его индекс
        {
            $Smallest = $array[$i]
            
            $SmallestIndex = $i
        }
    }
    
    return $SmallestIndex
}


function SelectionSort
{
    [CmdletBinding()]
    param ( [System.Collections.ArrayList]$array )
    
    $NewArray = @()
    
    while ($array.Count -gt 0)
    {
        $Smallest = Find-Smallest $array
        
        $NewArray += $array[$Smallest]
        
        $array.RemoveAt($Smallest)
    }
    
    return $NewArray
}
#endregion


#region Chapter 3. Recursion
function Show-Countdown
{
    [CmdletBinding()]
    param ( $from )
    
    if ($from -gt 0)
    { # ныряем глубже в стек
        $from | Write-Warning
        
        Start-Sleep -Milliseconds 999
        
        return Show-Countdown ($from - 1)
    }
    else
    { # достигли предела
        return 0
    }
}


function Get-Factorial
{
    [CmdletBinding()]
    param ( [int]$n )
    
    if ( $n -gt 1)
    { # ныряем глубже в стек
        return ( $n * ( Get-Factorial ($n - 1) ) )
    }
    else
    { # достигли предела
        return 1
    }
}

#endregion


#region Chapter 4. Quicksort
function Get-ListSum
{
    [CmdletBinding()]
    param ( [System.Collections.ArrayList] $array )
    
    if ($null -eq $array[0])  # base case: empty list
    {
        return $array[0]
    }
    else  # recurse case: not empty list
    {
        $a0 = $array[0]
        
        $array.RemoveAt(0)
        
        return ($a0 + (Get-ListSum $array))
    }
}


function Get-ListCount
{
    [CmdletBinding()]
    param ( [System.Collections.ArrayList] $array )
    
    if ($null -eq $array)  # base case: empty list
    {
        return 0
    }
    else  # recurse case: not empty list
    {
        try
        {
            $array.RemoveAt(0)
            
            return (1 + (Get-ListCount $array))
        }
        catch
        {
            return 0
        }
    }
}


function Search-BinaryHardRecurse4
{
    [CmdletBinding()]
    param (
        $lst,       # отсортированный список чисел
        $target,    # целевое число
        $Shift = 0, # шаг (номер вопроса)
        $l = 0,     # нижняя граница
        $h = 0,      # верхняя граница
        $Predict = 0
    )
    
    if (0 -eq $Shift)
    {
        $Predict = 0
        
        do { $Predict++ } until ((1 -shl $Predict) -gt ($lst.Count - 1))
        
        $l = 0
            
        $h = $lst.Length - 1
    }
    
    if ($l -eq $h)  # base case: edges are equal
    {
        if ($target -eq $lst[$l] -and $Shift -le $Predict)
        {
            return $Shift  #($Predict, $Shift, $lst[$l], $lst[$h])
        }
        else
        {
            return -1
        }
    }
    else  # recurse case: edges are different
    {
        $Shift++
        
        $m = ($l + $h) -shr 1
        
        if ($target -ge $lst[$l] -and $target -le $lst[$m])
        {
            $h = $m  # число в диапазоне, сдвигаем верхнюю границу к середине
        }
        else
        {
            $l = $m + 1  # число в другом диапазоне, нижнюю границу ЗА середину
        }
        
        return (Search-BinaryHardRecurse4 $lst $target $Shift $l $h $Predict)
    }
}
#endregion


#region Chapter 5. Hash Tables
#endregion


#region Chapter 6. Breadth-first Search
#endregion


#region Chapter 7. Dijkstra’s algorithm
#endregion


#region Chapter 8. Greedy algorithms
#endregion


#region Chapter 9. Dynamic programming
#endregion


#region Chapter 10. K-nearest neighbors
#endregion


#region Chapter 11. Where to go next
#endregion